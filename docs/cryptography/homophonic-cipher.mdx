---
title: Homophonic Cipher
slug: /cryptography/homophonic-cipher
---

## Introduction

Homophonic cipher is an encryption technique where plaintext letters are mapped to one or more than one character. Generally, the plaintext letter with the highest frequency is given more characters than lower frequency letters. In this makes the analysis more difficult. 

## Explanation

In Homophonic Cipher we encrypt plaintext by replacing each letter with a variety of substitutes, the number of potential substitutes being proportional to the frequency of the letter used. If `a` accounts for `2%` of all letters in English, we assign `2` symbols to cipher it.

Let's have one example: 
```
Input :

plaintext : TESSERACTCODING
Output    : 60LL5KQEZE2R87U 

Mapping Table : 

|---------------------------------------------------|
|A B C D E F G H I J K L M N O P Q R S T U V W X Y Z|
|---------------------------------------------------|
|Q W E R T Y U I O P A S D F G H J K L Z X C V B N M|
|4       5       8         7 2       1 6            |
|---------------------------------------------------|
|        9                                          |
|---------------------------------------------------|
|        0                                          |
|---------------------------------------------------|
```

## Algorithm

- Build a function where we have the cipher symbols corresponding to the plaintext already computed. 
- Take the plaintext and check if it's in upper case or lower case.
- Check which letter the plaintext letter corresponds to and replace it with the symbol/letter from the mapped list.

## Code

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs
  defaultValue="cpp"
  values={[
    { label: 'C++', value: 'cpp', },
    { label: 'Java', value: 'java', },
  ]
}>
<TabItem value="cpp">

```cpp
#include<bits/stdc++.h>
using namespace std;

//Mapping one plain-text alphabet to more than one cipher-text alphabet.
void mapping(vector<vector<char> > &code) {    
	code[0].push_back('Q');code[0].push_back('4');
	code[1].push_back('W');
	code[2].push_back('E');
	code[3].push_back('R');
	code[4].push_back('T');code[4].push_back('5');code[4].push_back('9');code[4].push_back('0');
	code[5].push_back('Y');
	code[6].push_back('U');
	code[7].push_back('I');
	code[8].push_back('O');code[8].push_back('8');
	code[9].push_back('P');
	code[10].push_back('A');
	code[11].push_back('S');
	code[12].push_back('D');
	code[13].push_back('F');code[13].push_back('7');
	code[14].push_back('G');code[14].push_back('2');
	code[15].push_back('H');
	code[16].push_back('J');
	code[17].push_back('K');
	code[18].push_back('L');code[18].push_back('1');
	code[19].push_back('Z');code[19].push_back('6');
	code[20].push_back('X');
	code[21].push_back('C');
	code[22].push_back('V');
	code[23].push_back('B');
	code[24].push_back('N');
	code[25].push_back('M');	
}

/* Encodes characters of plain text by one of the 
several different cipher text letters using a map. */
string encode(string plain) {
	
	vector<vector<char> >code(26);
	mapping(code);
	string encrypted = "";
	int n = plain.length();
	for(int i = 0;i < n; ++i) {
		//if lowercase character
		if(plain[i] >= 97) {
			int num = (rand() % (code[plain[i] - 97].size()));
			
			if(code[plain[i]-97][num] >= 65)
				encrypted = encrypted+char(code[plain[i]-97][num]- 65 + 97);
			else
				encrypted = encrypted+code[plain[i]-97][num];
		}
		//uppercase letter
		else {
			int num = (rand() % (code[plain[i]-65].size()));
			encrypted = encrypted+code[plain[i]-65][num];
		}
	}
	
	return encrypted;
}

int main(){
	
	vector<vector<char> >code(26);
	mapping(code);
	
	string plain,encrypt;
	cout<<"Enter the plain text: ";
	cin>>plain;
	
	encrypt = encode(plain);
	cout<<"Cipher Text: "<<encrypt<<endl;
	
}
```

</TabItem>
<TabItem value="java">

```java
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Random;
import java.util.Scanner;

/*Homophonic Cipher is a substitution cipher, it replaces each letter with a varity of substitues, it is very similar
  to Monoalphabetic cipher, the key difference between Homophonic cipher and Monoalphabetic cipher is that, in
  Monoalphabetic cipher there is a constant replacement of character to another character whereas in Homophonic cipher
  we have a set of characters which we can substitute*/
public class HomophonicCipher
{
    // Character Mapping table for Homophonic Cipher
    private static HashMap<Character, List<Character>> homophonicSequence;
    
    /**
     * <p>
     * This is a public method which is used to initialize homophonicSequence with character mapping.
     * </p>
     */
    public void initializeHomophonicSequence()
    {
        // Initializing homophonicSequence
        homophonicSequence = new HashMap<Character, List<Character>>();
        
        // Character Mapping for letter 'A'
        List<Character> aCharacterList = new ArrayList<Character>();
        aCharacterList.add('Q');
        aCharacterList.add('4');
        HomophonicCipher.homophonicSequence.put('A', aCharacterList);
        
        // Character Mapping for letter 'B'
        List<Character> bCharacterList = new ArrayList<Character>();
        bCharacterList.add('W');
        HomophonicCipher.homophonicSequence.put('B', bCharacterList);
        
        // Character Mapping for letter 'C'
        List<Character> cCharacterList = new ArrayList<Character>();
        cCharacterList.add('E');
        HomophonicCipher.homophonicSequence.put('C', cCharacterList);
        
        // Character Mapping for letter 'D'
        List<Character> dCha60LL5KQEZE2R87UracterList = new ArrayList<Character>();
        dCharacterList.add('R');
        HomophonicCipher.homophonicSequence.put('D', dCharacterList);
        
        // Character Mapping for letter 'E'
        List<Character> eCharacterList = new ArrayList<Character>();
        eCharacterList.add('T');
        eCharacterList.add('5');
        eCharacterList.add('9');
        eCharacterList.add('0');
        HomophonicCipher.homophonicSequence.put('E', eCharacterList);
        
        // Character Mapping for letter 'F'
        List<Character> fCharacterList = new ArrayList<Character>();
        fCharacterList.add('Y');
        HomophonicCipher.homophonicSequence.put('F', fCharacterList);
        
        // Character Mapping for letter 'G'
        List<Character> gCharacterList = new ArrayList<Character>();
        gCharacterList.add('U');
        HomophonicCipher.homophonicSequence.put('G', gCharacterList);
        
        // Character Mapping for letter 'H'
        List<Character> hCharacterList = new ArrayList<Character>();
        hCharacterList.add('I');
        HomophonicCipher.homophonicSequence.put('H', hCharacterList);
        
        // Character Mapping for letter 'I'
        List<Character> iCharacterList = new ArrayList<Character>();
        iCharacterList.add('O');
        iCharacterList.add('8');
        HomophonicCipher.homophonicSequence.put('I', iCharacterList);
        
        // Character Mapping for letter 'J'
        List<Character> jCharacterList = new ArrayList<Character>();
        jCharacterList.add('P');
        HomophonicCipher.homophonicSequence.put('J', jCharacterList);
        
        // Character Mapping for letter 'K'
        List<Character> kCharacterList = new ArrayList<Character>();
        kCharacterList.add('A');
        HomophonicCipher.homophonicSequence.put('K', kCharacterList);
        
        // Character Mapping for letter 'L'
        List<Character> lCharacterList = new ArrayList<Character>();
        lCharacterList.add('S');
        HomophonicCipher.homophonicSequence.put('L', lCharacterList);
        
        // Character Mapping for letter 'M'
        List<Character> mCharacterList = new ArrayList<Character>();
        mCharacterList.add('D');
        HomophonicCipher.homophonicSequence.put('M', mCharacterList);
        
        // Character Mapping for letter 'N'
        List<Character> nCharacterList = new ArrayList<Character>();
        nCharacterList.add('F');
        nCharacterList.add('7');
        HomophonicCipher.homophonicSequence.put('N', nCharacterList);
        
        // Character Mapping for letter 'O'
        List<Character> oCharacterList = new ArrayList<Character>();
        oCharacterList.add('G');
        oCharacterList.add('2');
        HomophonicCipher.homophonicSequence.put('O', oCharacterList);
        
        // Character Mapping for letter 'P'
        List<Character> pCharacterList = new ArrayList<Character>();
        pCharacterList.add('H');
        HomophonicCipher.homophonicSequence.put('P', pCharacterList);
        
        // Character Mapping for letter 'Q'
        List<Character> qCharacterList = new ArrayList<Character>();
        qCharacterList.add('J');
        HomophonicCipher.homophonicSequence.put('Q', qCharacterList);
        
        // Character Mapping for letter 'R'
        List<Character> rCharacterList = new ArrayList<Character>();
        rCharacterList.add('K');
        HomophonicCipher.homophonicSequence.put('R', rCharacterList);
        
        // Character Mapping for letter 'S'
        List<Character> sCharacterList = new ArrayList<Character>();
        sCharacterList.add('L');
        sCharacterList.add('1');
        HomophonicCipher.homophonicSequence.put('S', sCharacterList);
        
        // Character Mapping for letter 'T'
        List<Character> tCharacterList = new ArrayList<Character>();
        tCharacterList.add('Z');
        tCharacterList.add('6');
        HomophonicCipher.homophonicSequence.put('T', tCharacterList);
        
        // Character Mapping for letter 'U'
        List<Character> uCharacterList = new ArrayList<Character>();
        uCharacterList.add('X');
        HomophonicCipher.homophonicSequence.put('U', uCharacterList);
        
        // Character Mapping for letter 'V'
        List<Character> vCharacterList = new ArrayList<Character>();
        vCharacterList.add('C');
        HomophonicCipher.homophonicSequence.put('V', vCharacterList);
        
        // Character Mapping for letter 'W'
        List<Character> wCharacterList = new ArrayList<Character>();
        wCharacterList.add('V');
        HomophonicCipher.homophonicSequence.put('W', wCharacterList);
        
        // Character Mapping for letter 'X'
        List<Character> xCharacterList = new ArrayList<Character>();
        xCharacterList.add('B');
        HomophonicCipher.homophonicSequence.put('X', xCharacterList);
        
        // Character Mapping for letter 'Y'
        List<Character> yCharacterList = new ArrayList<Character>();
        yCharacterList.add('N');
        HomophonicCipher.homophonicSequence.put('Y', yCharacterList);
        
        // Character Mapping for letter 'Z'
        List<Character> zCharacterList = new ArrayList<Character>();
        zCharacterList.add('M');
        HomophonicCipher.homophonicSequence.put('Z', zCharacterList);
    }
    
    // the encryption function
    public String encrypt(String plainText)
    {
        // used to store cipher text
        StringBuilder cipherText = new StringBuilder("");
        
        // Iterates through plainText
        for (int i = 0; i < plainText.length(); i++)
        {
            // Gets List of mapping characters to the current character
            List<Character> characterList = HomophonicCipher.homophonicSequence.get(plainText.charAt(i));
            // If character mapping is found
            if (characterList != null)
            {
                // Random character index is picked from the set of characters
                Integer indexToUse = new Random().nextInt(characterList.size());
                // character selected by random is appended to cipherText
                cipherText.append(characterList.get(indexToUse));
            }
            // If character mapping is not found
            else
            {
                // Without encryption plainText character will be appended to cipherText
                cipherText.append(plainText.charAt(i));
            }
        }
        // cipher text is retured
        return cipherText.toString();
        
    }
    
    // driver code
    public static void main(String[] args)
    {
        // Create an object of String class for storing plain text to be entered by the user
        String plainText;                                 
        // Created an object of Scanner class for asking for user input.
        Scanner scan = new Scanner(System.in); 
        // Created an object of HomophonicCipher for accessing it's method for encryption
        HomophonicCipher homophonicCipher = new HomophonicCipher(); 
        
        // Initializing homophonicCipher
        homophonicCipher.initializeHomophonicSequence();
        
        // Asking user to enter plain text
        System.out.print("Please Enter Plain Text:");
        plainText = scan.nextLine();
        
        // Accessing method 'encrypt' of HomophonicCipher class to encrypt plainText
        String cipherText = homophonicCipher.encrypt(plainText.toUpperCase());
        // Printing cipher text
        System.out.print("Cipher Text: " + cipherText);
        
        // Closing the Scanner object scan
        scan.close();
    }
}
```

</TabItem>
</Tabs>

## Sample Input and Output

### Input:

```
Enter the plain text: TESSERACTCODING
```

### Output:

```
Cipher Text: 60LL5KQEZE2R87U
```

## Complexity Analysis


- Time  complexity - O(n)
- Space complexity - O(n)

## Credits

- [Sejal G](https://github.com/Sejal-G) contributed the [C++ implementation](https://github.com/TesseractCoding/NeoAlgo/blob/master/C-Plus-Plus/cryptography/Homophonic_Cipher.cpp)
- [Purav Uday Desai](https://github.com/PuravUdayDesai) contributed the [Java implementation](https://github.com/TesseractCoding/NeoAlgo/blob/master/Java/cryptography/HomophonicCipher.java) 
