---
title: Next smallest element to the left
slug: /competitive-programming/next-smallest-left
---

## Introduction

Given an array, find the next smallest element to the left of each element in the array. An easy but less efficient method is to use two loops and find out the next smallest element to the right. But using stacks is an efficient way of solving the problem

## Algorithm

- Initialise a stack and array.
- Traverse the given array from the left.
- If the stack is empty, then push -1 to array.
- If the stack is not empty and topmost element is smaller than th element then push topmost element to array.
- If not then pop elements from the stack till it is empty or topmost element is smaller.

## Examples

#### Example 1

```
Let the array be 1, 3.
Traverse the array from the left.
The stack is empty, hence no smaller element to the right of 1.
For 3, the topmost element 1 is compared to 3. 
1 is less than 3, so the next smallest element to the left of 3 is 1.
The resultant array is -1, 1.
```

#### Example 2

```
Let the array be 9, 4.
The stack is initially empty, hence no smaller element to the right of 9.
For 4, the topmost element 9 is compared to 4.
It is greater than 4, so elements in stack are popped out till stack is empty or topmost element is smaller.
Stack is empty on popping 9, so -1 is pushed to the array.
The resultant array is -1, -1.
```

## Code

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

<Tabs
  defaultValue="cpp"
  values={[
    { label: 'C++', value: 'cpp', },
    { label: 'Python', value: 'py', },
  ]
}>

<TabItem value="cpp">

```cpp
#include<bits/stdc++.h>
using namespace std;

void nextSmallestToLeft (int a[],int n)
{
    stack <int> s;
    vector <int> v;

    for(int i = 0 ; i < n ; i++)
    {
        if (s.empty())
        v.push_back(-1);
        else if (s.empty() != true && s.top() < a[i])
        v.push_back(s.top());
        else if (s.empty() != true && s.top() > a[i])
        {
            while (s.empty() != true && s.top() > a[i])
            {
                s.pop();
            }
            if (s.empty())
            v.push_back (-1);
            else if (s.top() < a[i])
            v.push_back(s.top());            
        }
        s.push(a[i]);
    }

    for(int i = 0 ; i < n ; i++)
    cout << v[i] << " ";
}

//Driver function
int main()
{
    int n;
    cout << "Enter number of elements: ";
    cin >> n;
    int a[n];
    cout << "Enter the elements:\n";
    for(int i = 0 ; i < n ; i++)
    cin >> a[i];
    nextSmallestToLeft(a,n);
}
```
</TabItem>
</Tabs>

## Sample I/O

#### Input 

```
Enter number of elements: 4
Enter the elements:
1 2 4 5 
```

#### Output

```
 -1 1 2 4
```

## Complexity Analysis

- Time Complexity: `O(n^2)`
- Space Complexity:`O(n)`

## Credits

- [Sayani Mallick]() for the C++ implementation

