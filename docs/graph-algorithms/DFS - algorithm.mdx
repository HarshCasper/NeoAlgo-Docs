---
title: DFS Algorithm
slug: /graph-algorithms/DFS-algorithm
---
## Introduction

Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking.

## Explanation

- “Search as deep as possible first.”
 - Explore edges out of the most recently discovered vertex v.<br/>
 - When all edges of v have been explored, backtrack to explore other edges leaving the vertex from which v was discovered (its predecessor).<br/>
 - Continue until all vertices reachable from the original source are discovered.<br/>

- If any undiscovered vertices remain, then <br/>
 - Chose one of them as a new source <br/>
 - Repeat the search from that source.<br/>

## Applications of Depth First Search

- Cycle Detection
- Maze Solver
- Resolve Dependencies (Topological Sort)
- Job Scheduling 
  - Courses Ordering in CHP
  - Find Strongly Connected Components (SCC) in Directed G 

    
## Algorithm

- Create a recursive function that takes the index of node and a visited array.
- Mark the current node as visited and print the node.
- Traverse all the adjacent and unmarked nodes and call the recursive function with index of adjacent node.

## Code
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs
  defaultValue="cpp"
  values={[
    { label: 'C++', value: 'cpp', },
    { label: 'Python', value: 'py', },
    { label: 'Java', value: 'java', },
  ]
}>

<TabItem value="cpp">

```cpp
#include<bits/stdc++.h>
using namespace std;
void dfs(int source, vector <int> adj[],bool visited[]){
    //visit the source
    cout<<source<<" ";
    //mark visited as true
    visited[source] = true;
    //Traverse all its adjacents
    for(auto s:adj[source]){
        //Check if the adjacent is not visited
        if(!visited[s]){
            //Do the same for this vertex i.e. call dfs for this adjacent as source
            //This lets you reach the depth of the graph, So you traverse down a hirearchy instead of going to all adjacents as we do in bfs
            dfs(s,adj,visited);
        }
    }
}
int main(){
    int n,m; cin>>n>>m;
    vector <int> adj[n];
    int a,b;
    for(int i=0;i<m;i++){
        cin>>a>>b;
        adj[a].push_back(b);
        adj[b].push_back(a);
    }
    bool visited[n];
    memset(visited,false,sizeof(visited));
    //Calling dfs for all non visited graphs to cover non connected compnents in graph
    for(int i=0;i<n;i++){
        if(!visited[i]){
            dfs(i,adj,visited);
        }
    }cout<<endl;
    return 0;
}

```

</TabItem>
<TabItem value="py">

```py
class Graph:
    def __init__(self, vertices):
        self.vertices = vertices
        self.adjMatrix = [[0 for j in range(vertices)]for i in range(vertices)]

    def addEdge(self, v1, v2):
        self.adjMatrix[v1][v2] = 1
        self.adjMatrix[v2][v1] = 1

    def removeEdge(self, v1, v2):
        if self.containsEdge(v1, v2):
            self.adjMatrix[v1][v2] = 0
            self.adjMatrix[v2][v1] = 0

    def containsEdge(self, v1, v2):
        '''
        Summary line:
        Helps us to check whether a particular edge is present in a graph or not.
        Args:
        v1- first vertex from which that edge passes
        v2- second vertex from which that edge passes
        Returns-
        Boolean value indicating whether that edge is present or not.
        '''
        if self.adjMatrix[v1][v2] != 0:
            return True
        else:
            return False

    def getPathDFShelper(self, sv, ev, visited):
        '''
        Summary line:
        Helps us to perform depth first search in the graph using a stack and adjacency matrix.
        Working:
        We use the visited list to mark `True` for every vertex we visit.
        After being visited, we push the next element of the vertex
        into the stack and continue untill we reach a point where
        the next element is also marked `True` for visited.
        Args:
        sv- Starting vertex
        ev- Ending vertex
        visited- array containing boolean value
        to indicate if that node has been visited before.
        Return:
        Boolean value and a list of nodes
        obtained after DFS traversal.
        '''
        if sv == ev:
            path = [ev]
            return True, path
        visited[sv] = True
        for i in range(self.vertices):
            if self.adjMatrix[sv][i] == 1 and visited[i] == False:
                hasPath, path = self.getPathDFShelper(i, ev, visited)
                if hasPath == True:
                    path.append(sv)
                    return True, path
        return False, []

    def getPathDFS(self, sv, ev):
        visited = [False for i in range(self.vertices)]
        hasPath, path = self.getPathDFShelper(sv, ev, visited)
        if hasPath == True:
            return path
        return list()


if __name__ == "__main__":
    print("Enter no of vertices and edges-")
    v, e = map(int, input().split())
    if v > 0 and e > 0:
        g = Graph(v)
        for i in range(e):
            print("Enter vertex1 and vertex2 having edge-")
            v1, v2 = map(int, input().split())
            g.addEdge(v1, v2)
        sv, ev = map(int, input().split())
        path = g.getPathDFS(sv, ev)
        for i in path:
            print(i, end = " ")

```

</TabItem>
<TabItem value="java">

```java
import java.util.Scanner;

public class DFS{

	//dfs function for connected graph
	public static void dfsHelper(int[][] edges,
	 int noVertices, int startVertex, boolean[] visited){

	 	System.out.print(startVertex +  " ");
	 	visited[startVertex] = true;

	 	for(int i = 0; i < noVertices; i++){
	 		if(i == startVertex)
	 			continue;

	 		/*If there is an edge b/w starting vertex
	 		and curr vertex, call print on curr vertex */
	 		if(edges[startVertex][i] == 1){

	 			/*If we have already visited curr vertex,
	 			we will not call print on it */
	 			if(visited[i])
	 				continue;

	 			dfsHelper(edges, noVertices, i, visited);
	 		}
	 	}

	}

	//this works for disconnected graph also
	public static void dfs(int[][] edges, int noVertices){
		boolean[] visited = new boolean[noVertices];

		for(int i = 0; i < noVertices; i++){
			if(!visited[i])
				dfsHelper(edges, noVertices, i, visited);
		}

	}

	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);

		System.out.println("Enter the number of vertices in Graph : ");
		int n = scanner.nextInt();  // no. of vertices

		System.out.println("Enter the number of edges in the Graph : ");
		int e = scanner.nextInt();  // no. of edges

		// Adjacency Matrix
		int[][] edges = new int[n+1][n+1];

		//Take input of all edges
		System.out.println("Enter the edges :");
		for(int i = 0; i < e; i++){
			int firstVertex = scanner.nextInt();
			int secondVertex = scanner.nextInt();
			edges[firstVertex][secondVertex] = 1;
			edges[secondVertex][firstVertex] = 1;;
		}

		System.out.println("DFS Traversal : ");
		dfs(edges, n);
	}
}


```

</TabItem>
</Tabs>

## Sample Input and Output

#### Input : 
```
Sample Case : 
Enter the number of vertices in Graph : 
10
Enter the number of edges in the Graph : 
8
Enter the edges :
1 2
1 3
2 4
4 6
3 5
5 0
7 8
8 9
  ```
#### Output: 
```
DFS Traversal : 
0 5 3 1 2 4 6 7 8 9
```

## Complexity Analysis
- Let E denote the number of Edges and V denote the number of Vertices.
- Time Complexity: `O(V + E)`
- Space Complexity: `O(V)`

## Credits 
- [Dhruv Panwar](https://github.com/dhruvinfo28) for the [C++ Implementation](https://github.com/TesseractCoding/NeoAlgo/blob/master/C-Plus-Plus/graphs/dfs_of_a_graph.cpp)
- [Pranav](https://github.com/Pranav016) for the [Python Implementation](https://github.com/TesseractCoding/NeoAlgo/blob/master/Python/graphs/DFS.py)
- [Rohit Kumar](https://github.com/rohitkumar-rk) for the [Java Implementation](https://github.com/TesseractCoding/NeoAlgo/blob/master/Java/graphs/DFS.java)