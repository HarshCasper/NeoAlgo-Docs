---
title: Breadth First Search
slug: /graph-algorithms/breadth-first-search
---
## Introduction

Breadth-first search (BFS) is an algorithm to traverse/search the data structure tree or a graph. It is similar to level-order traversal in trees. It starts at the root node and explores all of the neighbor nodes at the present node before moving on to the nodes at the next depth level. BFS uses a **'queue'** data structure for traversing the nodes.


## Explanation

- The BFS traversal of the graph is similar to the level-order traversal in trees. It starts the traversal with a given `source vertex (V)`, visits all of the vertices adjacent to the given vertex and `pushes them all to a queue` in order of visiting and `pops it from the front of the queue`, visits all adjacent nodes and pushes them into the queue. This process is repeated until the queue is empty or all of the vertices are visited.


#### Quick Example :  

- Consider the graph shown below. The vertex numbered 0 is the source vertex i.e. the BFS traversal will start from the vertex 0.

![graph20](https://user-images.githubusercontent.com/72685035/116195549-fd5e4200-a74f-11eb-9df9-0f68eb0ce664.gif) 
**Step 1] Start at vertex 0**

![graph40](https://user-images.githubusercontent.com/72685035/116195625-1830b680-a750-11eb-8e2a-f586882273c8.gif) 
**Step 2] Visit all the neighbors of node 0 first**

![graph41](https://user-images.githubusercontent.com/72685035/116195639-1b2ba700-a750-11eb-92d2-31345cc6a5cf.gif)
**Step 3] Then visit the other vertices neighbors & so on**

## Algorithm

- Create a `boolean array` say `visited[]`.

- Create a `queue`, mark the source vertex visited as `visited[s] = true`, and push it into the queue.

- Loop until the `queue is not empty`, repeat the below steps:

   * Pop an element from the queue and print the popped element.

   * Traverse all of the vertices adjacent to the vertex popped from the queue.

   * If any of the adjacent vertexes are not already visited, mark it visited and push it to the queue.


## Code

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs
  defaultValue="cpp"
  values={[
    { label: 'C++', value: 'cpp', },
    { label: 'Java', value: 'java', },
    { label: 'Python', value: 'py', }
    ]
}>

<TabItem value="cpp">

```cpp
#include <iostream>
  
#include <list>

using namespace std;

class Graph {
    int V;

    list<int>* adj;

public:
    Graph(int V);

    void addEdge(int v, int w);

    void BFS(int s);
};

Graph::Graph(int V)
{
    this->V = V;
    adj = new list<int>[V];
}

void Graph::addEdge(int v, int w)
{
    adj[v].push_back(w);
}

void Graph::BFS(int s)
{
    bool* visited = new bool[V];
    for (int i = 0; i < V; i++)
        visited[i] = false;

    list<int> queue;

    visited[s] = true;
    queue.push_back(s);

    list<int>::iterator i;

    while (!queue.empty()) {
        s = queue.front();
        cout << s << " ";
        queue.pop_front();

        for (i = adj[s].begin();
             i != adj[s].end(); ++i) {
            if (!visited[*i]) {
                visited[*i] = true;
                queue.push_back(*i);
            }
        }
    }
}
 
int main()
{
    // Create a graph given in the above diagram
    int V, E, i, S, A, B;

    cout << "Enter the No of Vertex \n";
    cin >> V;
    Graph g(V);

    cout << "Enter the No of Edges \n";
    cin >> E;

    for (i = 0; i < E; i++) {
        cin >> A >> B;
        g.addEdge(A, B);
    }

    cout << "Enter the Edges to traverse Graph\n";
    cin >> S;

    cout << "The BFS Traversal of given Graph is : "
        << S << " \n";

    g.BFS(S);

    return 0;
}
```

</TabItem>

<TabItem value="java">

```java
import java.util.*;

public class BFS {

	public static void breadthFirst(int edges[][],int V) {
//		A visited array to mark if the node is visited then not to go there again
		boolean visited[]=new boolean[V];
		
		for(int i=0;i<V;i++) {
			if(!visited[i]) {
				breadthFirstHelper(edges,visited,i);
			}
		}
	}
	
	public static void breadthFirstHelper(int edges[][],boolean visited[],int sv) {
		
		int V=edges.length;
		
		visited[sv]=true;
		
		Queue<Integer> queue=new LinkedList<Integer>();
		queue.add(sv);
		
		while(!queue.isEmpty()) {
			
			int size=queue.size();
			
			for(int i=0;i<size;i++) {
				int frontNode=queue.poll();
				for(int j=0;j<V;j++) {
					if(edges[frontNode][j]==1&&!visited[j]) {
						queue.add(j);
						visited[j]=true;
					}
				}
				System.out.print(frontNode+" ");
			}
		}
		
	}
	
	public static void main(String[] args) {
		
		Scanner sc=new Scanner(System.in);
	
		System.out.println("Enter the No of Vertex : ");
		int V=sc.nextInt();
		
		System.out.println("Enter the No of Edges : ");
		int E=sc.nextInt();
		
        // Adjaceny Matrix :
		int edges[][]=new int[V][V];
		
       // Taking edges as input :
		System.out.println("Enter the Edges to traverse graph:");
		for(int i=0;i<E;i++) {
			int sv=sc.nextInt();
			int ev=sc.nextInt();
			edges[sv][ev]=1;
			edges[ev][sv]=1;
		}
		
		System.out.println("BFS Traversal of given Graph is: ");
		breadthFirst(edges,V);

	}
```

</TabItem>

<TabItem value="py">

```py
import queue


class Graph:
    def __init__(self, vertices):
        self.vertices = vertices
        self.adjMatrix\
            = [[0 for j in range(self.vertices)]for i in range(self.vertices)]

    def addEdge(self, v1, v2):
        self.adjMatrix[v1][v2] = 1
        self.adjMatrix[v2][v1] = 1

    def removeEdge(self, v1, v2):
        if self.containsEdge(v1, v2):
            self.adjMatrix[v1][v2] = 0
            self.adjMatrix[v2][v1] = 0

    def containsEdge(self, v1, v2):
        '''
        Summary line-
        Helps us to check whether a particular
        edge is present in a graph or not.
        '''
        if self.adjMatrix[v1][v2] != 0:
            return True
        else:
            return False

    def __str__(self):
        return str(self.adjMatrix)

    def bfsHelper(self, sv, ev, visited, path):
        '''
        Summary line-
        Helps us to perform breadth first search in the graph using a queue.
        Working-
        We use the visited list to mark `True` for every element we visit.
        We get the elements from the queue,
        mark it visited and push its neighboring vertices.
        Variable names-
        sv- Starting vertex
        ev- Ending vertex
        '''
        q = queue.Queue()
        q.put(sv)
        visited[sv] = True
        while not q.empty():
            cur = q.get()
            for i in range(self.vertices):
                if self.adjMatrix[cur][i] > 0 and visited[i] is False:
                    path[i] = cur
                    if i == ev:
                        print(ev, end=" ")
                        return True
                    q.put(i)
                    visited[i] = True

    def bfs(self, sv, ev):
        visited = [False for j in range(self.vertices)]
        path = dict()
        if self.bfsHelper(sv, ev, visited, path) is True:
            return path
        return dict()

if __name__ == "__main__":
    print("Enter no of vertices and edges-")
    v, e = map(int, input().split())
    if v > 0 and e > 0:
        g = Graph(v)
        for i in range(e):
            print("Enter the No of Vertex & no of Edges-")
            v1, v2 = map(int, input().split())
            g.addEdge(v1, v2)
        print("Enter starting and ending vertex")
        sv, ev = map(int, input().split())
        path = g.bfs(sv, ev)
        x = path.get(ev, -1)
        while x != -1:
            print(x, end=" ")
            x = path.get(x, -1)


```

</TabItem>
</Tabs>

## Sample Input and Output

#### Input:

```
Enter the No of Vertex : 
4
Enter the No of Edges  : 
4
Enter the Edges to traverse Graph :
0 1
1 2
0 2
2 3
```

#### Output:

```
The BFS Traversal of given Graph is : 
0 1 2 3 
```

## Complexity Analysis
- Let E denote the number of Edges and V denote the number of Vertices.
- Time  complexity - `O(|V|+|E|)`
- Space complexity - `O(|V|)`

## Credits

- [Rajiv Singh](https://github.com/iamrajiv) contributed the [C++ implementation](https://github.com/TesseractCoding/NeoAlgo/blob/master/C-Plus-Plus/graphs/BFS1.cpp)
- [Ricardo Prins](https://github.com/ricardoprins) contributed the [Java implementation](https://github.com/TesseractCoding/NeoAlgo/blob/master/Java/graphs/BFS.java)
- [Ricardo Prins](https://github.com/ricardoprins) contributed the [Python implementation](https://github.com/TesseractCoding/NeoAlgo/blob/master/Python/graphs/BFS.py)

