---
title: Breadth First Search
slug: /graph-algorithms/breadth-first-search
---

## Introduction
Breadth-first search (BFS) is an algorithm for traversing or searching tree or graph data structures.
It starts at the tree root (or some arbitrary node of a graph, sometimes referred to as a 'search key'[1]),
and explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.

## Explanation

- Given an undirected & Connected Graph (V, E) <br />
  V: Vertices E: Edges <br />
- Goal: methodically explore every vertex and every edge <br />
- “Explore” a graph, turning it into a tree<br />
- One vertex at a time<br />
- Expand frontier of explored vertices across its breadth<br />
- Discovers all vertices at distance k from s before those at distance k+1
- A level-by-level order traversal<br />
- For example, in the following graph, we start traversal from vertex 2. When we come to vertex 0, we look for all adjacent vertices of it. 2 is also an adjacent vertex of 0. If we don’t mark visited vertices, then 2 will be processed again and it will become a non-terminating process.
 A Breadth First Traversal of the following graph is 2, 0, 3, 1.<br />
 [![graph.png](https://media.geeksforgeeks.org/wp-content/uploads/bfs-5.png)]<br />

## Applications of Breadth First Traversal

- Find Connected Components in Undirected G
- Web Crawling
- Social N/W: Friend Finder
- Pocket Cube (2x2x2 Rubic Cube)
- Garbage Collector


## Algorithm

- Builds a tree over the graph
- Pick a source vertex to be the root
- Find (“discover”) all of its children, then all of their children, etc.
- Associate vertex “colors” to guide the algorithm
- white  vertices have not been discovered
- All vertices start out white
- Grey vertices are discovered but not fully explored
- They may be adjacent to white vertices
- Black vertices are discovered and fully explored
- They are adjacent only to black and gray vertices
- Explore vertices by scanning neighbors of grey vertices

## Code

```cpp

#include <iostream>
#include <queue>
#include <algorithm>

/*
Best First Search Algorithm is a search algorithm that is used to find a path between source vertex 
and target vertex in an undirected weighted graph. It is a search algorithm that works on a specific
rule. It is an example of "Informed Search" algorithm as it uses an evaluation function to decide 
which adjacent is most promising and then explores it.
It uses the concept of a priority queue (min heap) to store costs of nodes.
*/

#include <bits/stdc++.h>
using namespace std;

//Function to implement best first search algorithm
void bestFirstSearchAlgorithm(int sv, int tv, int n, vector<vector<pair<int, int> > > graph)
{

    //array for keeping track of visited vertices
    vector<bool> visited(n, false);

    //min heap priority queue for storing cost of nodes
    priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;

    //inserted source position in the priority queue
    pq.push(make_pair(0, sv));

    //mark source vertex as visited
    visited[sv] = true;

    //array to store path from the source to the target vertex
    vector<int> path;

    while (!pq.empty()) {

        int temp = pq.top().second;

        path.push_back(temp);
        pq.pop();

        //If target vertex is found then exit from the loop
        if (temp == tv)
            break;

        for (int i = 0; i < graph[temp].size(); i++) {
            //For each neighbouring vertex of temp
            // Continue if it is already visited
            if (visited[graph[temp][i].second])
                continue;
            //Else mark it visited and insert it in the priority queue
            else {
                visited[graph[temp][i].second] = true;
                pq.push(graph[temp][i]);
            }
        }
    }

    cout << "Path between source vertex and target vertex: " << endl;
    for (int i = 0; i < path.size(); i++) {
        cout << path[i] << " ";
    }
    cout << endl;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    vector<vector<pair<int, int> > > graph;

    int vertices, edges;

    cout << "Input number of vertices and edges" << endl;
    cin >> vertices >> edges;

    graph.resize(vertices);

    cout << "Input edges: start vertex, end vertex and weight of edge between them" << endl;
    for (int i = 0; i < edges; i++) {
        int a, b, cost;
        cin >> a >> b >> cost;
        graph[a].push_back(make_pair(cost, b));
        graph[b].push_back(make_pair(cost, a));
    }

    int sv, tv;

    cout << "Input Source vertex and target vertex" << endl;
    cin >> sv >> tv;

    bestFirstSearchAlgorithm(sv, tv, vertices, graph);

    return 0;
}

/*
Sample Output:
Input number of vertices and edges
14 13
Input edges: start vertex, end vertex and weight of edge between them
0 1 3
0 2 6
0 3 5
1 4 9 
1 5 8
2 6 12
2 7 14
3 8 7
8 9 5
8 10 6
9 11 1
9 12 10
9 13 2
Input Source vertex and target vertex
0 9
Output:
Path between source vertex and target vertex:
0 1 3 2 8 9
Time Complexity: O(V log V)
Space Complexity: O(V^2)
where,
    V = Number of vertices
*/

```

```java

// Java program to print BFS traversal from a given source vertex.
// BFS(int s) traverses vertices reachable from s.
import java.io.*;
import java.util.*;
 
// This class represents a directed graph using adjacency list
// representation
class Graph
{
    private int V;   // No. of vertices
    private LinkedList<Integer> adj[]; //Adjacency Lists
 
    // Constructor
    Graph(int v)
    {
        V = v;
        adj = new LinkedList[v];
        for (int i=0; i<v; ++i)
            adj[i] = new LinkedList();
    }
 
    // Function to add an edge into the graph
    void addEdge(int v,int w)
    {
        adj[v].add(w);
    }
 
    // prints BFS traversal from a given source s
    void BFS(int s)
    {
        // Mark all the vertices as not visited(By default
        // set as false)
        boolean visited[] = new boolean[V];
 
        // Create a queue for BFS
        LinkedList<Integer> queue = new LinkedList<Integer>();
 
        // Mark the current node as visited and enqueue it
        visited[s]=true;
        queue.add(s);
 
        while (queue.size() != 0)
        {
            // Dequeue a vertex from queue and print it
            s = queue.poll();
            System.out.print(s+" ");
 
            // Get all adjacent vertices of the dequeued vertex s
            // If a adjacent has not been visited, then mark it
            // visited and enqueue it
            Iterator<Integer> i = adj[s].listIterator();
            while (i.hasNext())
            {
                int n = i.next();
                if (!visited[n])
                {
                    visited[n] = true;
                    queue.add(n);
                }
            }
        }
    }
 
    // Driver method to
    public static void main(String args[])
    {
        Graph g = new Graph(4);
 
        g.addEdge(0, 1);
        g.addEdge(0, 2);
        g.addEdge(1, 2);
        g.addEdge(2, 0);
        g.addEdge(2, 3);
        g.addEdge(3, 3);
 
        System.out.println("Following is Breadth First Traversal "+
                           "(starting from vertex 2)");
 
        g.BFS(2);
    }
}

```

```py

# Python3 Program to print BFS traversal
# from a given source vertex. BFS(int s)
# traverses vertices reachable from s.
from collections import defaultdict
 
# This class represents a directed graph
# using adjacency list representation
class Graph:
 
    # Constructor
    def __init__(self):
 
        # default dictionary to store graph
        self.graph = defaultdict(list)
 
    # function to add an edge to graph
    def addEdge(self,u,v):
        self.graph[u].append(v)
 
    # Function to print a BFS of graph
    def BFS(self, s):
 
        # Mark all the vertices as not visited
        visited = [False] * (max(self.graph) + 1)
 
        # Create a queue for BFS
        queue = []
 
        # Mark the source node as
        # visited and enqueue it
        queue.append(s)
        visited[s] = True
 
        while queue:
 
            # Dequeue a vertex from
            # queue and print it
            s = queue.pop(0)
            print (s, end = " ")
 
            # Get all adjacent vertices of the
            # dequeued vertex s. If a adjacent
            # has not been visited, then mark it
            # visited and enqueue it
            for i in self.graph[s]:
                if visited[i] == False:
                    queue.append(i)
                    visited[i] = True
 
# Driver code
 
# Create a graph given in
# the above diagram
g = Graph()
g.addEdge(0, 1)
g.addEdge(0, 2)
g.addEdge(1, 2)
g.addEdge(2, 0)
g.addEdge(2, 3)
g.addEdge(3, 3)
 
print ("Following is Breadth First Traversal"
                  " (starting from vertex 2)")
g.BFS(2)
 

```

## Complexity
- Time Complexity: O(V+E) V: Vertices  E: Edges

## Credits
- [Geeks for Geeks Website](https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/) for the [Java & Python Implementation] and the give example.
- [Neo Algo Project](https://github.com/TesseractCoding/NeoAlgo/blob/master/C-Plus-Plus/graphs/Best_First_Search_Algorithm.cpp) for the [C++ implementation]
