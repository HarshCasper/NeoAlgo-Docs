---
title: Prim Algorithm
slug: /graph-algorithms/prim-algorithm
---

## Introduction

The Prim's algorithm is a greedy algorithm. This algorithm is used to find a minimum spanning tree for a weighted undirected graph. This means it finds a subset of the edges that forms a tree that includes every vertex, where the total weight of all the edges in the tree is minimized.

## Explanation

From a given undirected graph find the path such that it covers all the edges and has minimum total weight.

### Quick Example :

![Step1](https://cdn.programiz.com/sites/tutorial2program/files/pa_1.png)
![Step2](https://cdn.programiz.com/sites/tutorial2program/files/pa_2.png)
![Step3](https://cdn.programiz.com/sites/tutorial2program/files/pa_3.png)
![Step4](https://cdn.programiz.com/sites/tutorial2program/files/pa_4.png)
![Step5](https://cdn.programiz.com/sites/tutorial2program/files/pa_5.png)
![Step6](https://cdn.programiz.com/sites/tutorial2program/files/pa_6.png)

## Algorithm

- Initialize the minimum spanning tree with a vertex chosen at random.
- Create a set mstSet that keeps track of vertices already included in MST. 
- Assign a key value to all vertices in the input graph. Initialize all key values as INFINITE. Assign key value as 0 for the first vertex so that it is picked first.
- Find all the edges that connect the tree to new vertices, find the minimum and add it to the tree.
- Keep repeating the steps.

## Code 
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs
  defaultValue="cpp"
  values={[
    { label: 'C++', value: 'cpp', },
    { label: 'Java', value: 'java', },
  ]
}>
<TabItem value="cpp">

```cpp
// C++ Program for Prim's Algorithm
#include<bits/stdc++.h>

/*This includes functions like strlen and strcpy,It's the C++ version of header from C*/
using namespace std;
int operation(int array[], int row, int coloumn, int graph[4][4]);
#define number 4
/* separate function is declared to form process and output
which takes 2 for loops with min val of vertex displays output 
in 2 columns where Weight of ele and Edge of graph*/
int operation(int array[], int row, int coloumn, int graph[4][4]) {
  int least_val = 100;
  for (int index_x = 0; index_x < number; index_x++) {
    if (array[index_x]) {
      for (int index_y = 0; index_y < number; index_y++) {
        if (!array[index_y] && graph[index_x][index_y]) {
          if (least_val > graph[index_x][index_y]) {
            least_val = graph[index_x][index_y];
            row = index_x, coloumn = index_y;
          }
        }
      }
    }
  }
  cout << graph[row][coloumn] << "  " << row << " - " << coloumn << endl;
  array[coloumn] = true;
}
/* in main we give inputs to graph array and calls operation function */
int main() {
  int all_edges;
  int array[number];
  /*memset Sets the first num bytes of the block of memory 
  pointed by ptr to the specified value faster than loop*/
  memset(array, false, sizeof(array));
  all_edges = 0;
  array[0] = true;
  cout << "enter the elements into graph array " << endl;
  /* taking the inputs for graph in form of loop
  which is of having number(of rows and coloumns) */
  int row, coloumn;
  int graph[number][number];
  for (int i = 0; i < number; i++) {
    for (int j = 0; j < number; j++) {
      cin >> graph[i][j];
    }
  }
  cout << "Weight of ele," << " " << "Edge of graph" << "\n";
  /* iterate while loop till all edges are lesser than num-1 */
  while (number - 1 > all_edges) {
    row = 0, coloumn = 0;
    operation(array, row, coloumn, graph);
    all_edges++;
  }
  return 0;
}
```

</TabItem>
<TabItem value="java">

```java
// Java Program for Prim's Algorithm
import java.util.Arrays;

class PGraph {

  public void Prim(int G[][], int V) {

    int INF = 9999999;

    int no_edge; // number of edge

    // create a array to track selected vertex
    // selected will become true otherwise false
    boolean[] selected = new boolean[V];

    // set selected false initially
    Arrays.fill(selected, false);

    // set number of edge to 0
    no_edge = 0;

    // the number of egde in minimum spanning tree will be
    // always less than (V -1), where V is number of vertices in
    // graph

    // choose 0th vertex and make it true
    selected[0] = true;

    // print for edge and weight
    System.out.println("Edge : Weight");

    while (no_edge < V - 1) {
      // For every vertex in the set S, find the all adjacent vertices
      // , calculate the distance from the vertex selected at step 1.
      // if the vertex is already in the set S, discard it otherwise
      // choose another vertex nearest to selected vertex at step 1.

      int min = INF;
      int x = 0; // row number
      int y = 0; // col number

      for (int i = 0; i < V; i++) {
        if (selected[i] == true) {
          for (int j = 0; j < V; j++) {
            // not in selected and there is an edge
            if (!selected[j] && G[i][j] != 0) {
              if (min > G[i][j]) {
                min = G[i][j];
                x = i;
                y = j;
              }
            }
          }
        }
      }
      System.out.println(x + " - " + y + " :  " + G[x][y]);
      selected[y] = true;
      no_edge++;
    }
  }

  public static void main(String[] args) {
    PGraph g = new PGraph();

    // number of vertices in grapj
    int V = 5;

    // create a 2d array of size 5x5
    // for adjacency matrix to represent graph
    int[][] G = { { 0, 9, 75, 0, 0 }, { 9, 0, 95, 19, 42 }, { 75, 95, 0, 51, 66 }, { 0, 19, 51, 0, 31 },
        { 0, 42, 66, 31, 0 } };

    g.Prim(G, V);
  }
}
```
</TabItem>
</Tabs>

## Sample Input and Output
#### Input :
```
enter the elements into graph array                                                                                                                                     
1 4 78 15                                                                                                                                                                            
1 75 48 6                                                                                                                                                                            
45 7 8 36                                                                                                                                                                            
2 4 67 59   
```

#### Output :
```
Weight of ele, Edge of graph                                                                                                                                             
4  0 - 1                                                                                                                                                                             
6  1 - 3                                                                                                                                                                             
48  1 - 2 
```
#### Input :
```
Enter a number: 
5  10  2  6
4  17  19 3
1  5   8  20
15 1  16  7 
```
#### Output :
```
Weight of ele, Edge of graph
2 0 -2
5 2 -1
3 1 -3
```
## Complexity Analysis
- Time Complexity: `O(ElogV) where V no of vertices and E no of edges`
- Space Complexity: `O(V) where V no of vertices`

## Credits

   - [Devara Khurma Venkata Kavyasree](https://github.com/kavyasree-123) for the [C++ implementation](https://github.com/TesseractCoding/NeoAlgo/blob/master/C-Plus-Plus/ds/prims_algo.cpp)
   - [Ricardo Prins](https://github.com/ricardoprins) for the [Java implementation](https://github.com/TesseractCoding/NeoAlgo/blob/master/Java/graphs/Prim_Algorithm.java)
