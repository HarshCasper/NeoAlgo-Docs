---
title: N Queens
slug: /backtracking/n-queens
---

## Introduction

The N Queen problem is placing N chess queens on an N x N chessboard such that no two queens can attack each other.
The chess queens can attack in any of the following directions: horizontal, vertical, and diagonal.
Output is the N x N binary matrices showing possible positions for queens such that they cannot attack each other, where 1 represents the correct place for the queen. If no such valid solution exists, then output is `false`.

## Explaination

The backtracking approach is used to solve this problem. Queens are placed one by one in different columns, starting from the leftmost column. While placing a queen in a column, we see if that position is safe or not. If it's safe, mark this row and column as part of the solution else, backtrack and return false.

## Algorithm

- Step 1: Start from the leftmost position.
- Step 2: If all queens are placed, then return true.
- Step 3: Try all rows in the column. For each row, do the following:
  - a) If this position is safe for the queen to be placed, then mark this [row, column] as part of the solution and see if this position leads to a solution or not using recursion.
  - b) If that position leads to a solution, then return true else unmark [row, column] this position
    i.e., backtrack and go to a) and repeat the same procedure for other rows.
- Step 4: If we don't get any solution after trying all rows, then return false.

## Code

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

<Tabs
  defaultValue="cpp"
  values={[
    { label: 'C++', value: 'cpp', },
    { label: 'Python', value: 'py', },
  ]
}>

<TabItem value="cpp">

```cpp
#include <bits/stdc++.h>
using namespace std;

#define N 20

void solve(bool board[N][N], bool cols[N], bool ndiag[2*N-1], bool rdiag[2*N-1], int row, string asf, int n) {

    if(row == n) {
        cout << asf << '.' << '\n';
        return;
    }

    for(int col=0; col<n; col++) {
        if(cols[col] == false && ndiag[row+col] == false &&
            rdiag[row-col+n-1] == false) {
                // place the queen
                cols[col] = true;
                ndiag[row+col] = true;
                rdiag[row-col+n-1] = true;
                board[row][col] = true;
                solve(board, cols, ndiag, rdiag, row+1, asf+to_string(row)+"-"+to_string(col)+", ", n);
                // backtrack
                cols[col] = false;
                ndiag[row+col] = false;
                rdiag[row-col+n-1] = false;
                board[row][col] = false;
            }
    }
}

int main() {
	int n;
	cin >> n;

	bool board[N][N];
    bool cols[N];
    bool ndiag[2*N-1], rdiag[2*N-1];

	// initialize
	for(int i = 0; i < n; i++)
		for(int j = 0; j < n; j++)
			board[i][j] = false;

    // initialize that no column has a queen
	for(int i = 0; i < n; i++)
		cols[i] = false;

	for(int i = 0; i < 2*n-1; i++) {
		ndiag[i] = false;
		rdiag[i] = false;
	}

	solve(board, cols, ndiag, rdiag, 0, "", n);
}
```

</TabItem>

<TabItem value="py">

```python
# Main function argument =size of the board
def n_queens(board_size):

    # Occupied Diagonals and Columns
    # For right and left Diagonal respectively
    diagonal1 = {}
    diagonal2 = {}
    Col = {}

    ans = place_queen(0, [], board_size, diagonal1, diagonal2, Col)

    return ans

# Recursive Function to check and place the queens

def place_queen(row, a, n, diagonal1, diagonal2, Col):

    # If the answer is found, row will be equal to the size of the board i.e. n
    if(row == n):
        return a
    R = row + 1

    for C in range(1, n + 1):
        # Check that particular Column is free to place a queen or not
        if((C not in Col) and ((R + C) not in diagonal1) and ((R - C) not in diagonal2)):

            # Add the Column and their respective Diagonals to the dictionary
            # to mark they are Occupied
            Col[C] = 0
            diagonal1[R + C] = 0
            diagonal2[R - C] = 0
            chk = place_queen(
                row + 1, a + [(row, C - 1)], n, diagonal1, diagonal2, Col)

            # If the answer is found, Stop the recursion
            if chk:
                return chk

            # Deleaating the Column and Diagonals to vacant that place
            del diagonal1[R + C]
            del Col[C]
            del diagonal2[R - C]

    return False

# -------------------------------Driver Code-------------------------------

if __name__ == "__main__":
    n = int(input("Enter the Board Size: "))
    answer = n_queens(n)
    if not answer:
        print("Queens cannot be placed in the given Chessboard")

    else:
        print("Queens are Placed in the chessboard")
        print("Position :", *answer)

```

</TabItem>

</Tabs>

## Sample Input/Output

**Input:**

```
Enter the Board Size: 3
```

**Output:**

```
Queens cannot be placed in the given Chessboard
```

**Input:**

```
Enter the Board Size: 4
```

**Output:**

```
Queens are Placed in the chessboard
Position : (0, 1) (1, 3) (2, 0) (3, 2)
    0       1       2       3
  |-------|-------|-------|-------|
  |       |       |       |       |
0 |       |   X   |       |       |
  |       |       |       |       |
  |-------|-------|-------|-------|
  |       |       |       |       |
1 |       |       |       |   X   |
  |       |       |       |       |
  |-------+-------+-------+-------+
  |       |       |       |       |
2 |   X   |       |       |       |
  |       |       |       |       |
  |-------|-------|-------|-------|
  |       |       |       |       |
3 |       |       |   X   |       |
  |       |       |       |       |
  |-------|-------|-------|-------|

```

## Complexity Analysis

- `N` is the size of the Chessboard.
- Space Complexity : O(n^2)
- Time Complexity : upperbounded by O(n^n)

## Credits

- [YASH01009](https://github.com/YASH01009) for the [C++ implementation](https://github.com/TesseractCoding/NeoAlgo/blob/master/C-Plus-Plus/cp/NQueens.cpp)
- [Akash Kumar Bhagat](https://github.com/charlie219) and [Rajiv Singh](https://github.com/iamrajiv) for the [Python implementation](https://github.com/TesseractCoding/NeoAlgo/blob/master/Python/backtracking/N_Queens.py)
