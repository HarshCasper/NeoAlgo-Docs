---
title: What are Search Algorithms?
slug: /searching-algorithms
---

## Introduction

Searching is a method of finding whether an element or a value exists in the given list of elements or values. If the element exists, then it returns its position. In the real world, there are many useful applications based on searching, be that seeking a whole database to find a certain file or it might be a simple connection from your contact list. If you want to find something from a collection of items, you got to need this algorithmic process.

Few Notable examples :
* Finding a particular user from a social media network.
* Looking for the desired word from a dictionary.
* Querying the availability of products from an eCommerce website.
* Using it to solve other problems including, `Knapsack` and `Sudoku`.
* Helping search engines to display the right results.

## Searching Algorithm

In computer terms, an algorithm that solves the searching problem is a searching algorithm. Simple as it is. 

With that said, many smart minds, came up with their way of searching techniques - or to be clear in terms - searching algorithms to perform searching.

Below is the list of some Searching Algorithms :
* Linear Search
* Binary Search
* Jump Search
* Interpolation Search
* Exponential Search
* Sublist Search
* Fibonacci Search

## Popular Searching Algorithms

There might be many such algorithms ( with the above mentioned ), but only those are good which are sufficient in most cases. In short, only those are considered as good which has good time complexity ( run time ) & space complexity ( space-time ).

Let's go one by one & find out which is good over the other.

### Linear Search

As the name hints, it works linearly. Meaning, it starts from the very first element till it finds the required/asked element in the collection. Clearly, 
* Best Case - The element to be searched, is the first element.
* Worst Case - The element to be searched, is the endmost element.

The practical uses of linear search are a very rare cause of the way its search. It's quite costly (with respect to time) to go for, example, it will be really hard for AWS developers to go through the complete database from the starting point to get what they want. 

### Binary Search

Widely used algorithm, where elements are searched in a unique way of "Divide and Conquer". Elaborating, the algorithm works as : 

> Get the collection and divide it into two sub-collections until you won't get the element.

It creates two halves, checks whether the element is in the first half or second half. If second, then halves it into yet another two parts, then check where the element is going to reside, and so on. It will keep repeating itself till it finds out the element.

While stating, it should be clear that it works on sorted collection. Disadvantage if you choose the bad sorting algorithm. Else it is good to go.

### Jump Search

With the mind flow as of binary search, jump search adds its jump step to do searching. 

> Take a fixed number of jumps to skip few elements.

If the collection contains, some, 36 elements then the jump search will take a jump of 6 from the starting i.e Jump from index 0 to 6, then check if the given element is smaller than the 6th element of the collection, if it is, then loops through these 0 to 6 elements to get that element, that is, performing a linear search.

 As you can note, it works on a sorted collection of elements only.

### Interpolation Search

An improvement over the binary search, interpolation works by calculating the probe position using a formula :

```mdx

pos =  startIndex + 
       [
           (searchKey - array[startIndex]) * (endIndex - lowIndex) /
           (array[endIndex] - array[startIndex]) 
       ]

```

If the calculated pos ( probe position ) matches the element to be searched, then it returns the position of the element. Else it will check whether the element is larger than the element present at the probe position ( `pos` ), and if so, then it will search the element in the right sub-array.


### Exponential Search

Exponential search works on a sorted collection of items. The algorithm is about finding the range in which the key will be lying & then passing that range to binary search to get that desired element.

The range is decided as :
1. Start with position 0th index, do the check i.e the element at position 0 matches with the element to be searched. If not, 
2. Start from 1st index to `i * 2`th index, where `i` starts from 1,  <br />
    Get the range i.e., 1st index to index till `i * 2`, do the check, if not, increase value of `i`
3. Follow step `2` until the endIndex of the range is larger than the key. If found,
4. Pass that range to the binary search algorithm.


### Fibonacci Search

Based on the famous mathematical series called Fibonacci, the Fibonacci search works in a manner of finding the smallest fib element which is greater than equal to the element to be searched in the collection. Fibonacci series is as :

| 0   | 1   | 1   | 2   | 3   | 5   | 8   | 13   | 21   | 34   |
| --- | --- | --- | --- | --- | --- | --- | ---  | ---  | --- |

which is a series of elements whose value is computed from the sum of the previous two elements : `Fib(k) = Fib(k-1) + Fib(k-2)`

> Find the fib element from the derived Fibonacci series, based on the result, recur the half sub array.

As one might notice, it is a `Divide and Conquer` principle which needs a sorted collection of items to perform the search operation.


## Complexity Analysis

|                      | Best Case | Worst Case | Average Case   | Space Complexity  |
|----------------------|-----------|------------|----------------|-------------------|
| Linear Search        | O(1)      | O(n)       | O(n/2)         | O(1)              |
| Binary Search        | O(1)      | O(log n)   | O(log n)       | O(log n) / O(1)   |
| Jump Search          | O(1)      | O(√n)      | O(√n)          | O(1)              |
| Interpolation Search | O(1)      | O(n)       | O(log(log(n))) | O(1)              |
| Exponential Search   | O(1)      | O(log n)   | O(log n)       | O(log n) / O(1)   |
| Fibonacci Search     | O(1)      | O(log n)   | O(log n)       | O(1)              |


 <Highlight color="#000">Note</Highlight> - The space complexity of binary & exponential search is written as - O(log n)/O(1) cause of the different approaches in which they can be implemented. If the approach is recursive, then space complexity will be O(log n) else for the normal iterative approach, its O(1) of space complexity.

## Conclusion

Taking note of efficiency and both the complexities, a good choice of a searching algorithm should be made.

<Highlight color="#000">Thank You!</Highlight>

<!-- Highlighting purpose -->

export const Highlight = ({children, color}) => (
  <span
    style={{
      backgroundColor: color,
      borderRadius: '5px',
      color: '#fff',
      padding: '0.2rem 0.5rem',
      fontSize: '0.9rem'
    }}>
    {children}
  </span>
);


